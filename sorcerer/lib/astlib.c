/*
 * astlib.c
 *
 * SOFTWARE RIGHTS
 *
 * We reserve no LEGAL rights to SORCERER -- SORCERER is in the public
 * domain.  An individual or company may do whatever they wish with
 * source code distributed with SORCERER or the code generated by
 * SORCERER, including the incorporation of SORCERER, or its output, into
 * commerical software.
 *
 * We encourage users to develop software with SORCERER.  However, we do
 * ask that credit is given to us for developing SORCERER.  By "credit",
 * we mean that if you incorporate our source code into one of your
 * programs (commercial product, research project, or otherwise) that you
 * acknowledge this fact somewhere in the documentation, research report,
 * etc...  If you like SORCERER and have developed a nice tool with the
 * output, please mention that you developed it using SORCERER.  In
 * addition, we ask that this header remain intact in our source code.
 * As long as these guidelines are kept, we expect to continue enhancing
 * this system and expect to make other tools available as they are
 * completed.
 *
 * SORCERER 1.00B
 * Terence Parr
 * AHPCRC, University of Minnesota
 * 1992-1994
 */

#include <stdio.h>
#include "constants.h"
#include <ctype.h>

#define SORCERER_TRANSFORM

#include "CASTBase.h"
#include "astlib.h"

#include <stdarg.h>

               /* String Scanning/Parsing Stuff */

#define StringScanMaxText 50

typedef struct stringlexer {
      signed int c;
      char *input;
      char *p;
      char text[StringScanMaxText];
    } StringLexer;

#define LPAREN      1
#define RPAREN      2
#define PERCENT     3
#define INT       4
#define COLON     5
#define POUND     6
#define PERIOD      7
#define StringScanEOF -1
#define VALID_SCAN_TOKEN(t)   (t>=LPAREN && t<=PERIOD)

static char *scan_token_tbl[] = {
  "invalid",  /*  0 */
  "LPAREN", /*  1 */
  "RPAREN", /*  2 */
  "PERCENT",  /*  3 */
  "INT",    /*  4 */
  "COLON",  /*  5 */
  "POUND",  /*  6 */
  "PERIOD", /*  7 */
};

char *scan_token_str(int t)
{
    if ( VALID_SCAN_TOKEN(t) ) return scan_token_tbl[t];
    else if ( t==StringScanEOF ) return "<end-of-string>";
    else return "<invalid-token>";
}

typedef struct stringparser {
    int token;
    StringLexer *lexer;
    int num_labels;
} StringParser;

          /* This type ONLY USED by ast_scan() */

typedef struct _scanast {
    struct _scanast *right, *down;
    int token;
    int label_num;
} ScanAST;

static void stringlexer_init(StringLexer *scanner, char *input);
static void stringparser_init(StringParser *, StringLexer *);
static ScanAST *stringparser_parse_scanast(char *templ, int *n);
static ScanAST *stringparser_parse_tree(StringParser *parser);
static ScanAST *stringparser_parse_element(StringParser *parser);
static void stringscan_advance(StringLexer *scanner);
static int stringscan_gettok(StringLexer *scanner);

/* build a tree (root child1 child2 ... NULL)
 * If root is NULL, simply make the children siblings and return ptr
 * to 1st sibling (child1).  If root is not single node, return NULL.
 *
 * Siblings that are actually sibling lists themselves are handled
 * correctly.  For example #( NULL, #( NULL, A, B, C), D) results
 * in the tree ( NULL A B C D ).
 *
 * Requires at least two parameters with the last one being NULL.  If
 * both are NULL, return NULL.
 *
 * The ast_down and ast_right down/right pointers are used to make the tree.
 */
SORAST *
ast_make(SORAST *rt, ...)
{
  va_list ap;
  register SORAST *child, *sibling=NULL, *tail = NULL, *w;
  SORAST *root;

  va_start(ap, rt);
  root = rt;

  if ( root != NULL )
    if ( root->ast_down != NULL ) return NULL;
  child = va_arg(ap, SORAST *);
  while ( child != NULL )
  {
    /* find end of child */
    for (w=child; w->ast_right!=NULL; w=w->ast_right) {;}
    if ( sibling == NULL ) {sibling = child; tail = w;}
    else {tail->ast_right = child; tail = w;}
    child = va_arg(ap, SORAST *);
  }
  if ( root==NULL ) root = sibling;
  else root->ast_down = sibling;
  va_end(ap);
  return root;
}

/* The following push and pop routines are only used by ast_find_all() */

static void _push(SORAST **st, int *sp, SORAST *e)
{
  (*sp)--;
  require((*sp)>=0, "stack overflow");
  st[(*sp)] = e;
}

static SORAST *_pop(SORAST **st, int *sp)
{
  SORAST *e = st[*sp];
  (*sp)++;
  require((*sp)<=MaxTreeStackDepth, "stack underflow");
  return e;
}

/** Is 'u' a subtree of 't' beginning at the root? */
int ast_match_partial(SORAST *t, SORAST *u)
{
  SORAST *sib;

  if ( u==NULL ) return 1;
  if ( t==NULL ) if ( u!=NULL ) return 0; else return 1;

  for (sib=t; sib!=NULL&&u!=NULL; sib=sib->ast_right, u=u->ast_right)
  {
    if ( sib->token != u->token ) return 0;
    if ( sib->ast_down!=NULL )
      if ( !ast_match_partial(sib->ast_down, u->ast_down) ) return 0;
  }
  return 1;
}

/**
 * Find all occurrences of u in t.
 * 'cursor' must be initialized to 't'.  It eventually
 * returns NULL when no more occurrences of 'u' are found.
 */
SORAST *ast_find_all(SORAST *t, SORAST *u, SORAST **cursor)
{
  SORAST *sib;
  static SORAST *template_stack[MaxTreeStackDepth];
  static int tsp = MaxTreeStackDepth;

  if ( *cursor == NULL ) return NULL;
  if ( *cursor!=t ) sib = *cursor;
  else {
    /* else, first time--start at top of template 't' */
    tsp = MaxTreeStackDepth;
    sib = t;
    /* bottom of stack is always a NULL--"cookie" indicates "done" */
    _push(template_stack, &tsp, NULL);
  }

keep_looking:
  if ( sib==NULL )  /* hit end of sibling list */
  {
    sib = _pop(template_stack, &tsp);
    if ( sib == NULL ) { *cursor = NULL; return NULL; }
  }

  if ( sib->token != u->token )
  {
    /* look for another match */
    if ( sib->ast_down!=NULL )
    {
      if ( sib->ast_right!=NULL ) _push(template_stack, &tsp, sib->ast_right);
      sib=sib->ast_down;
      goto keep_looking;
    }
    /* nothing below to try, try next sibling */
    sib=sib->ast_right;
    goto keep_looking;
  }

  /* found a matching root node, try to match what's below */
  if ( ast_match_partial(sib, u) )
  {
    /* record sibling cursor so we can pick up next from there */
    if ( sib->ast_down!=NULL )
    {
      if ( sib->ast_right!=NULL ) _push(template_stack, &tsp, sib->ast_right);
      *cursor = sib->ast_down;
    }
    else if ( sib->ast_right!=NULL ) *cursor = sib->ast_right;
    else *cursor = _pop(template_stack, &tsp);
    return sib;
  }

  /* no match, keep searching */
  if ( sib->ast_down!=NULL )
  {
    if ( sib->ast_right!=NULL ) _push(template_stack, &tsp, sib->ast_right);
    sib=sib->ast_down;
  }
  else sib = sib->ast_right;  /* else, try to right if zip below */
  goto keep_looking;
}

/** are two trees exactly alike? */
int ast_match(SORAST *t, SORAST *u)
{
  SORAST *sib;

  if ( t==NULL ) if ( u!=NULL ) return 0; else return 1;
  if ( u==NULL ) return 0;

  for (sib=t; sib!=NULL&&u!=NULL; sib=sib->ast_right, u=u->ast_right)
  {
    if ( sib->token != u->token ) return 0;
    if ( sib->ast_down!=NULL )
      if ( !ast_match(sib->ast_down, u->ast_down) ) return 0;
  }
  return 1;
}

static int ast_scanmatch(ScanAST *t, SORAST *u, SORAST **labels[], int *n)
{
  ScanAST *sib;

  if ( t==NULL ) if ( u!=NULL ) return 0; else return 1;
  if ( u==NULL ) return 0;

  for (sib=t; sib!=NULL&&u!=NULL; sib=sib->right, u=u->ast_right)
  {
    /* make sure tokens match; token of '0' means wildcard match */
    if ( sib->token != u->token && sib->token!=0 ) return 0;
    /* we have a matched token here; set label pointers if exists */
    if ( sib->label_num>0 )
    {
      require(labels!=NULL, "label found in template, but no array of labels");
      (*n)++;
      *(labels[sib->label_num-1]) = u;
    }
    /* match what's below if something there and current node is not wildcard */
    if ( sib->down!=NULL && sib->token!=0 )
      if ( !ast_scanmatch(sib->down, u->ast_down, labels, n) ) return 0;
  }
  return 1;
}

void ast_insert_after(SORAST *a, SORAST *b)
{
  SORAST *end;
  require(a!=NULL, "ast_insert_after: NULL input tree");
  if ( b==NULL ) return;
  /* find end of b's child list */
  for (end=b; end->ast_right!=NULL; end=end->ast_right) {;}
  end->ast_right = a->ast_right;
  a->ast_right = b;
}

void ast_append(SORAST *a, SORAST *b)
{
  SORAST *end;
  require(a!=NULL&&b!=NULL, "ast_append: NULL input tree");
  /* find end of child list */
  for (end=a; end->ast_right!=NULL; end=end->ast_right) {;}
  end->ast_right = b;
}

SORAST *ast_tail(SORAST *a)
{
  SORAST *end;
  require(a!=NULL, "ast_tail: NULL input tree");
  /* find end of child list */
  for (end=a; end->ast_right!=NULL; end=end->ast_right) {;}
  return end;
}

SORAST *ast_bottom(SORAST *a)
{
  SORAST *end;
  require(a!=NULL, "ast_bottom: NULL input tree");
  /* find end of child list */
  for (end=a; end->ast_down!=NULL; end=end->ast_down) {;}
  return end;
}

SORAST *ast_cut_between(SORAST *a, SORAST *b)
{
  SORAST *end, *ret;
  require(a!=NULL&&b!=NULL, "ast_cut_between: NULL input tree");
  /* find node pointing to b */
  for (end=a; end->ast_right!=NULL&&end->ast_right!=b; end=end->ast_right)
    {;}
  require(end->ast_right!=NULL, "ast_cut_between: a,b not connected");
  end->ast_right = NULL;  /* don't want it point to 'b' anymore */
  ret = a->ast_right;
  a->ast_right = b;
  return ret;
}

SList *ast_to_slist(SORAST *t)
{
  SList *list=NULL;
  SORAST *p;

  for (p=t; p!=NULL; p=p->ast_right)
  {
    slist_add(&list, p);
  }
  return list;
}

SORAST *slist_to_ast(SList *list)
{
  SORAST *t=NULL, *last=NULL;
  SList *p;

  for (p = list->next; p!=NULL; p=p->next)
  {
    SORAST *u = (SORAST *)p->elem;
    if ( last==NULL ) last = t = u;
    else { last->ast_right = u; last = u; }
  }
  return t;
}

void
ast_free(SORAST *t)
{
    if ( t == NULL ) return;
    ast_free( t->ast_down );
    ast_free( t->ast_right );
    free( t );
}

int
ast_nsiblings(SORAST *t)
{
  int n=0;

  while ( t!=NULL )
  {
    n++;
    t = t->ast_right;
  }
  return n;
}

SORAST *
ast_sibling_index(SORAST *t, int i)
{
  int j=1;
  require(i>0, "ast_sibling_index: i<=0");

  while ( t!=NULL )
  {
    if ( j==i ) return t;
    j++;
    t = t->ast_right;
  }
  return NULL;
}

static void
scanast_free(ScanAST *t)
{
    if ( t == NULL ) return;
    scanast_free( t->down );
    scanast_free( t->right );
    free( t );
}

/*
 * ast_scan
 *
 * This function is like scanf(): it attempts to match a template
 * against an input tree.  A variable number of tree pointers
 * may be set according to the '%i' labels in the template string.
 * For example:
 *
 *   ast_scan("#( 6 #(5 %1:4 %2:3) #(1 %3:3 %4:3) )",
 *            t, &w, &x, &y, &z);
 *
 * Naturally, you'd want this converted from
 *
 *   ast_scan("#( RangeOp #(Minus %1:IConst %2:Var) #(Plus %3:Var %4Var) )",
 *        t, &w, &x, &y, &z);
 *
 * by SORCERER.
 *
 * This function call must be done withing a SORCERER file because SORCERER
 * must convert the token references to the associated token number.
 *
 * This functions parses the template and creates trees which are then
 * matched against the input tree.  The labels are set as they are
 * encountered; hence, partial matches may leave some pointers set
 * and some NULL.  This routines initializes all argument pointers to NULL
 * at the beginning.
 *
 * This function returns the number of labels matched.
 */
int ast_scan(char *templ, SORAST *tree, ...)
{
  va_list ap;
  ScanAST *t;
  int n, i, found=0;
  SORAST ***label_ptrs=NULL;

  va_start(ap, tree);

  /* make a ScanAST tree out of the template */
  t = stringparser_parse_scanast(templ, &n);

  /* make an array out of the labels */
  if ( n>0 )
  {
    label_ptrs = (SORAST ***) calloc(n, sizeof(SORAST **));
    require(label_ptrs!=NULL, "ast_scan: out of memory");
    for (i=1; i<=n; i++)
    {
      label_ptrs[i-1] = va_arg(ap, SORAST **);
      *(label_ptrs[i-1]) = NULL;
    }
  }

  /* match the input tree against the template */
  ast_scanmatch(t, tree, label_ptrs, &found);

  scanast_free(t);
  free(label_ptrs);

  return found;
}

static ScanAST *
new_scanast(int tok)
{
    ScanAST *p = (ScanAST *) calloc(1, sizeof(ScanAST));
    if ( p == NULL ) {fprintf(stderr, "out of mem\n"); exit(-1);}
  p->token = tok;
  return p;
}

static ScanAST *
stringparser_parse_scanast(char *templ, int *num_labels)
{
  StringLexer lex;
  StringParser parser;
  ScanAST *t;

  stringlexer_init(&lex, templ);
  stringparser_init(&parser, &lex);
  t = stringparser_parse_tree(&parser);
  *num_labels = parser.num_labels;
  return t;
}

static void
stringparser_match(StringParser *parser, int token)
{
  if ( parser->token != token ) sorcerer_panic("bad tree in ast_scan()");
}

/**
 * Match a tree of the form:
 *    (root child1 child2 ... childn)
 * or,
 *    node
 *
 * where the elements are integers or labeled integers.
 */
static ScanAST *
stringparser_parse_tree(StringParser *parser)
{
  ScanAST *t=NULL, *root, *child, *last = NULL;

  if ( parser->token != POUND )
  {
    return stringparser_parse_element(parser);
  }
  stringparser_match(parser,POUND);
  parser->token = stringscan_gettok(parser->lexer);
  stringparser_match(parser,LPAREN);
  parser->token = stringscan_gettok(parser->lexer);
  root = stringparser_parse_element(parser);
  while ( parser->token != RPAREN )
  {
    child = stringparser_parse_element(parser);
    if ( t==NULL ) { t = child; last = t; }
    else { last->right = child; last = child; }
  }
  stringparser_match(parser,RPAREN);
  parser->token = stringscan_gettok(parser->lexer);
  root->down = t;
  return root;
}

static ScanAST *
stringparser_parse_element(StringParser *parser)
{
  static char ebuf[100];
  int label = 0;

  if ( parser->token == POUND )
  {
    return stringparser_parse_tree(parser);
  }
  if ( parser->token == PERCENT )
  {
    parser->token = stringscan_gettok(parser->lexer);
    stringparser_match(parser,INT);
    label = atoi(parser->lexer->text);
    parser->num_labels++;
    if ( label==0 ) sorcerer_panic("%%0 is an invalid label");
    parser->token = stringscan_gettok(parser->lexer);
    stringparser_match(parser,COLON);
    parser->token = stringscan_gettok(parser->lexer);
    /* can label tokens and wildcards */
    if ( parser->token != INT && parser->token != PERIOD )
      sorcerer_panic("can only label tokens");
  }
  if ( parser->token == INT )
  {
    ScanAST *p = new_scanast(atoi(parser->lexer->text));
    parser->token = stringscan_gettok(parser->lexer);
    p->label_num = label;
    return p;
  }
  if ( parser->token == PERIOD )
  {
    ScanAST *p = new_scanast(0);  /* token of 0 is wildcard */
    parser->token = stringscan_gettok(parser->lexer);
    p->label_num = label;
    return p;
  }
  sprintf(ebuf, "mismatch token in ast_scan(): %s", scan_token_str(parser->token));
  sorcerer_panic(ebuf);
    return NULL; /* MR20 make -Wall happy */
}

static void
stringparser_init(StringParser *parser, StringLexer *input)
{
  parser->lexer = input;
  parser->token = stringscan_gettok(parser->lexer);
  parser->num_labels = 0;
}

static void
stringlexer_init(StringLexer *scanner, char *input)
{
  scanner->text[0]='\0';
  scanner->input = input;
  scanner->p = input;
  stringscan_advance(scanner);
}

static void
stringscan_advance(StringLexer *scanner)
{
  if ( *(scanner->p) == '\0' ) scanner->c = StringScanEOF;
  scanner->c = *(scanner->p)++;
}

static int
stringscan_gettok(StringLexer *scanner)
{
  char *index = &scanner->text[0];
  static char ebuf[100];

  while ( isspace(scanner->c) ) { stringscan_advance(scanner); }
  if ( isdigit(scanner->c) )
  {
    int tok = INT;
    while ( isdigit(scanner->c) ) {
      *index++ = scanner->c;
      stringscan_advance(scanner);
    }
    *index = '\0';
    return tok;
  }
  switch ( scanner->c )
  {
    case '#' : stringscan_advance(scanner); return POUND;
    case '(' : stringscan_advance(scanner); return LPAREN;
    case ')' : stringscan_advance(scanner); return RPAREN;
    case '%' : stringscan_advance(scanner); return PERCENT;
    case ':' : stringscan_advance(scanner); return COLON;
    case '.' : stringscan_advance(scanner); return PERIOD;
    case '\0' : return StringScanEOF;
    case StringScanEOF : return StringScanEOF;
    default  :
      sprintf(ebuf, "invalid char in ast_scan: '%c'", scanner->c);
      sorcerer_panic(ebuf);
            return 0; /* MR20 Make -Wall happy */
  }
}
